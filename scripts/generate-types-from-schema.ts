/**
 * Generate shared/types/schema.ts from zod db/schema files.
 */

import { readdir } from 'node:fs/promises'
import { parseSync } from 'oxc-parser'
import { stripIndent } from 'common-tags'

function toPascalCase(name: string) {
  return name
    .replace(/^([a-z])/, c => c.toUpperCase())
    .replace(/_([a-z])/g, (_, c) => c.toUpperCase())
}

const SCHEMA_PATH = './apps/server/src/db/schema'
const OUTPUT_FILE = './shared/types/schema.ts'

/** Directory entries */
const schemaDirectory = await readdir(SCHEMA_PATH, { withFileTypes: true })
const dependencies = new Set<string>()

for (const dirent of schemaDirectory) {
  if (dirent.isDirectory())
    continue

  if (dirent.name === 'index.ts')
    continue

  const file = Bun.file(`${dirent.parentPath}/${dirent.name}`)
  const source = await file.text()
  const ast = parseSync(dirent.name, source, {
    sourceType: 'module',
  })

  const exports = ast.module.staticExports

  exports.forEach(exported => {
    exported.entries.forEach(entry => {
      // Skip table relations based on naming convention
      if (entry.exportName.name?.match(/Relations$/))
        return

      dependencies.add(entry.exportName.name as string)
    })
  })
}

if (dependencies.size > 0) {
  const outputFile = Bun.file(OUTPUT_FILE)
  const writer = outputFile.writer()

  writer.write(stripIndent`
    /**
     * Generated by \`scripts/generate-types-from-schema.ts\`. Do NOT edit directly.
     */

    import * as schema from '../../apps/server/src/db/schema'
  `)

  writer.write("\n\n")

  const sortedDependencies = Array.from(dependencies).sort()
  sortedDependencies.forEach(dependency => {
    writer.write(stripIndent`
      export type ${toPascalCase(dependency)} = typeof schema.${dependency}.$inferSelect
    `)

    writer.write("\n")
  })

  writer.end()
}
